<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>cluesmash</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Sansita+Black:ital,wght@1,900&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
<script src="https://hammerjs.github.io/dist/hammer.min.js"></script>

<style>
/* Base */
body {
  margin: 0;
  font-family: 'Montserrat', sans-serif;
  background: #cce7ff;
  min-height: 100vh;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem 1rem 7rem; /* bottom padding so buttons don't cover content */
  color: white;
  user-select: none;
}
body { min-height: 100dvh; }
@supports not (height: 100dvh) { body { min-height: 100vh; } }

/* Scroll lock when Notes is open */
body.modal-open {
  position: fixed;
  width: 100%;
  overflow: hidden;
  top: var(--scroll-lock, 0);
}

/* Title */
#title-wrapper { display: flex; justify-content: center; margin-bottom: 0.5rem; }
#title-wrapper img { height: 40px; width: auto; }

/* Tabs row */
#tabs { display: flex; gap: 1rem; margin-bottom: 1rem; }

/* Tab buttons */
.tab {
  padding: 0.6rem 1.2rem; font-size: 1rem; font-weight: 700;
  border-radius: 16px; cursor: pointer; background: #fff; color: #000;
  border: 2px solid #000; box-shadow: 4px 4px 0 #000;
  transition: transform 0.1s ease-in-out, background 0.2s ease;
}
.tab:hover { transform: translateY(-1px); }
.tab:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 #000; }
.tab.active { background: #fff2b3; color: #000; }

/* Counts & progress */
#assessmentCounts { font-size: 1.2rem; margin-bottom: 0.5rem; color: #222; }
#progress {
  width: 90vw; max-width: 500px; height: 6px;
  background: rgba(255,255,255,0.3); border-radius: 3px;
  margin-bottom: 0.3rem; overflow: hidden;
}
#progressBar { height: 100%; width: 0%; background: #ffe6e6; transition: width 0.3s ease; }
#progressCount { font-size: 1.4rem; margin-bottom: 1.5rem; text-align: center; color: #222; }

/* Subtle fade on count change */
@keyframes countFade {
  0%   { opacity: 1; transform: translateY(0); }
  35%  { opacity: 0.35; transform: translateY(1px); }
  100% { opacity: 1; transform: translateY(0); }
}
#progressCount.count-fade { animation: countFade 240ms ease-out; }

/* Clue pane */
#card {
  background: white; color: #222; border: 3px solid #000; border-radius: 20px;
  padding: 2rem 1.5rem; font-size: 2.2rem; line-height: 1.4;
  box-shadow: 6px 6px 0 #000; text-align: center; width: 80vw; max-width: 380px;
  margin-bottom: 2rem; transition: transform 0.4s ease, opacity 0.4s ease;
}

/* Swipe animations */
#card.enter { transform: translateX(0) scale(1); opacity: 1; }
#card.swipe-left { transform: translateX(-150%) rotate(-20deg); opacity: 0; }
#card.swipe-right { transform: translateX(150%) rotate(20deg); opacity: 0; }
#card.swipe-down { transform: translateY(150%) rotate(15deg); opacity: 0; }

/* Answer block */
#answer {
  cursor: pointer; padding: 0 0.4em; border-radius: 6px; font-size: 2.2rem; font-weight: 700;
  display: inline-block; background: black; color: black; letter-spacing: 0.2em;
  font-family: 'Montserrat', sans-serif; transition: background-color 0.3s ease, color 0.3s ease;
}
#answer.revealed { background: none; color: #222; letter-spacing: normal; }

#writer {
  font-size: 1.3rem; color: #555; margin-top: 1rem;
  display: inline-flex; gap: .35rem; align-items: center; justify-content: center;
}

/* Star badge is plain */
#writerStar {
  font-size: 1.25rem;
  line-height: 1;
}

/* Emoji controls */
#buttons {
  display: flex; justify-content: center; gap: 2.2rem; width: auto; margin-bottom: 2rem; font-size: 2.5rem;
}
.emoji-btn { cursor: pointer; transition: transform 0.15s ease; text-shadow: 2px 2px 0 #000, 4px 4px 0 #000; }
.emoji-btn:hover, .emoji-btn:active { transform: scale(1.3); text-shadow: 3px 3px 0 #000, 6px 6px 0 #000; }

/* Bottom fixed buttons container */
#bottomButtons {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  display: flex;
  z-index: 1200;
}
#bottomButtons button {
  flex: 1;
  padding: 1rem;
  font-size: 1.1rem;
  border-radius: 0;
  color: white;
  text-align: center;
  border: none;
  cursor: pointer;
}
#exportBtn { background-color: #222; }
#resetBtn  { background-color: #e53935; }

/* Flash emoji */
#flashMessage {
  position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0.8);
  font-size: 5rem; opacity: 0; transition: opacity 0.4s ease, transform 0.4s ease;
  pointer-events: none; z-index: 999; text-shadow: 2px 2px 20px rgba(0,0,0,0.6);
}
#flashMessage.show { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }

/* Note overlay */
#noteOverlay {
  display: none; position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
  width: 75%; max-width: 300px; background: white; color: #222; border-radius: 20px;
  padding: 1.5rem; box-shadow: 0 10px 25px rgba(0,0,0,0.3); z-index: 1000;
}
#noteText {
  width: 85%; height: 120px; font-size: 2.2rem; padding: 1rem; border-radius: 12px;
  border: 2px solid #222; resize: none; background: white; color: #222; line-height: 1.4;
}
#noteOverlay button {
  margin-top: 1rem; padding: 0.6rem 1rem; font-weight: 700; border-radius: 16px;
  border: none; background: #222; color: white; cursor: pointer;
}

/* React palette (long-press on ‚ùå) */
#reactPalette{
  position: fixed; display: none; background:#fff; color:#000; border:2px solid #000;
  border-radius:14px; padding:.35rem .5rem; box-shadow:6px 6px 0 #000; z-index:1100; font-size:1.6rem; gap:.5rem;
}
#reactPalette .rp{ cursor:pointer; padding:.1rem .3rem; border-radius:10px; border:2px solid transparent; }
#reactPalette .rp.active{ background:#fff2b3; border-color:#000; }
</style>
</head>

<body>
<div id="title-wrapper">
  <img src="https://i.imgur.com/3cTvC1h.png" alt="cluesmash logo">
</div>

<div id="tabs">
  <div class="tab" data-view="all">All</div>
  <div class="tab" data-view="stars">Star Setters</div>
</div>

<div id="assessmentCounts">No: 0 | Workshop: 0 | Perfect: 0</div>
<div id="progress"><div id="progressBar"></div></div>
<div id="progressCount"></div>
<div id="flashMessage"></div>

<div id="card" style="display:none;"></div>

<div id="buttons">
  <span class="emoji-btn" onclick="guardUI(()=>animateSwipe('left', () => recordAssessment('No')))()" aria-label="No" role="button" tabindex="0">‚ùå</span>
  <span class="emoji-btn" onclick="guardUI(()=>animateSwipe('right', () => recordAssessment('Workshop')))()" aria-label="Workshop" role="button" tabindex="0">üí°</span>
  <span class="emoji-btn" onclick="guardUI(()=>animateSwipe('down', () => recordAssessment('Perfect')))()" aria-label="Perfect" role="button" tabindex="0">‚≠ê</span>
  <span class="emoji-btn" onclick="openNote()" aria-label="Note" role="button" tabindex="0">‚úèÔ∏è</span>
  <span class="emoji-btn" onclick="undoAssessment()" aria-label="Undo" role="button" tabindex="0">‚Ü©Ô∏è</span>
</div>

<div id="reactPalette" role="dialog" aria-hidden="true"></div>

<div id="bottomButtons">
  <button id="exportBtn" onclick="exportCSV()">Download Reviewed CSV</button>
  <button id="resetBtn" onclick="resetProgress()">Reset Progress</button>
</div>

<div id="noteOverlay">
  <textarea id="noteText" placeholder="Write here..."></textarea>
  <button onclick="saveNote()">OK</button>
</div>

<script>
/* Haptics */
function buzz(ms=20){ if(navigator.vibrate) navigator.vibrate(ms); }

/* ---------- One source only ---------- */
const SHEET_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vSsSUD7PgliCuhNkFFA3nyjes14LHlg1Gp2wuLlG5DU6FIp4CwP0lbrmGLuGe_DlhlbdM6fh_xwb2sZ/pub?output=csv";

/* Persistence keys */
const PROGRESS_KEY = "clueMatchProgress_main";
const VIEW_KEY     = "clueMatchViewMode";
const STARS_KEY    = "clueMatchSetterStars";

/* Data & state */
let allClues = [];
let clues = [];
let currentIndex = 0;
let currentKey = "";
let viewMode = localStorage.getItem(VIEW_KEY) || "all";
let pendingQueueRebuild = false;

let queueStartSize = 0;
let lastRemainingShown = null;

const historyKeys = [];
const counts = { No:0, Workshop:0, Perfect:0 };

/* UI */
const card = document.getElementById("card");
const flash = document.getElementById("flashMessage");
const progressBar = document.getElementById("progressBar");
const progressCount = document.getElementById("progressCount");
const assessmentCounts = document.getElementById("assessmentCounts");

/* UI locks */
let uiLocked = false;
let noteOpen = false;
let noteTargetKey = null;

/* React config */
const REACT_CHOICES = ['üëè','üòÇ','ü§Ø','ü§≠','üòú'];
const DEFAULT_REACT = { No:'‚ù§Ô∏è', Workshop:'üí°', Perfect:'‚≠ê' };

const reactPalette = document.getElementById('reactPalette');
let paletteOpen = false;

/* ---------- helpers ---------- */
function lockUI(){
  uiLocked = true;
  document.getElementById('buttons').style.pointerEvents = 'none';
  card.style.pointerEvents = 'none';
}
function unlockUI(){
  uiLocked = false;
  document.getElementById('buttons').style.pointerEvents = '';
  card.style.pointerEvents = '';
}
const guardUI = (fn)=> (...args)=>{ if(!uiLocked && !noteOpen) fn(...args); };

function normalizeRow(r, cols){
  const g = (obj, key) => (obj && key && obj[key]) || '';
  return {
    Clue:   String(g(r, cols.clue)).trim(),
    Answer: String(g(r, cols.answer)).trim(),
    Writer: String(g(r, cols.writer)).trim(),
    Email:  String(g(r, cols.email)).trim(),
    Id:     String(g(r, cols.id)).trim(),
    Assessment: String(g(r, cols.assess) || r?.Assessment || '').trim(),
    Note:       String(g(r, cols.note)   || r?.Note       || '').trim(),
    React:      String(g(r, cols.react)  || r?.React      || '').trim()
  };
}
function makeKey(r){
  const id = (r.Id||'').trim();
  if (id) return `ID¬ß${id}`;
  const s = [r.Clue||'', r.Answer||'', r.Writer||''].join('¬ß');
  let h=0; for(let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; }
  return `H¬ß${h}`;
}
function getWriterKey(name){
  return String(name||"").trim().replace(/\s+/g,' ').toLowerCase();
}

/* ---------- setter stars ---------- */
let setterStars = {};
function loadSetterStars(){
  try{
    const raw = localStorage.getItem(STARS_KEY);
    setterStars = raw ? JSON.parse(raw) : {};
    if (!setterStars || typeof setterStars !== 'object') setterStars = {};
  }catch{ setterStars = {}; }
}
function saveSetterStars(){
  try{ localStorage.setItem(STARS_KEY, JSON.stringify(setterStars)); }catch{}
}
function isStarredWriter(writerName){
  const k = getWriterKey(writerName);
  return !!setterStars[k];
}
function toggleStarWriter(writerName){
  const k = getWriterKey(writerName);
  if (!k) return false;
  setterStars[k] = !setterStars[k];
  saveSetterStars();
  return setterStars[k];
}

/* ---------- initial seed list ---------- */
const INITIAL_STAR_SETTERS = [
  "Adam Boyd","Adrian Paris","Adri√°n Par√≠s","Alex Ritter","Amanda C","Andrew Phelps","Annie R",
  "Arbel Feldman","Ayylexis","B N Z","Bill Lash","Billy Frank","CactusKex","Campbell H","Campsite",
  "Cole Baron","Dan Heath","David Hassine","Dean Harding","Doug Thompson","Dr W","Dr_H","Eamonn S",
  "Emilia D","Emily C","Ethan R","Eulerian","Felix H :)","Gabriel K.","Gregory Lewis","hattie",
  "hevorius","HFGO","Holypeanut","Jack Porter","jaimen","Jake Burrow","James & Ollie","Jamie T",
  "Jasel","Jay","JimbieP","Jo J","Jo O","Jody O","Johnny Quarrie","jojo!","jvsn89","Kelly Hicks",
  "Lee Hoe","Lucy","Luminoid","Martin","Mattasdqwe","mattLOLd","maya00","mayasibul00",
  "NatalyBenderskyShalem","Nate Mizelle","NateMiz","Nixfriarr","null","√ìin Stoch","Oren",
  "Pete Bowdon","Pete Craw","Peter Green","Phil McLean","Rob D","Rusty","Ryan Gittins","saintmark_w",
  "Sam Mount (Kaldar)","Schr√∂die‚Äôs Cat","Seivad","sngpretzel","Stevie Reed","Supware","Tanner Burton",
  "That Observer","Tyler Hopp","Tyr","vaughn","ventimony","Bluejay","hurblub"
];

function seedInitialStars(){
  if (!setterStars || typeof setterStars !== 'object') setterStars = {};
  let changed = false;
  for (const name of INITIAL_STAR_SETTERS){
    const k = getWriterKey(name);
    if (!k) continue;
    if (!(k in setterStars)){
      setterStars[k] = true;
      changed = true;
    }
  }
  if (changed) saveSetterStars();
}

/* ---------- queue rebuild ---------- */
function rebuildQueue(keepKey=""){
  const unassessed = allClues.filter(c => !c.Assessment);
  let next = unassessed;

  if (viewMode === "stars"){
    next = next.filter(c => isStarredWriter(c.Writer));
  }

  if (viewMode === "all"){
    next = next
      .map((c, idx) => ({c, idx, starred: isStarredWriter(c.Writer)}))
      .sort((a,b)=>{
        if (a.starred !== b.starred) return a.starred ? -1 : 1;
        return a.idx - b.idx;
      })
      .map(x=>x.c);
  }

  clues = next;

  if (keepKey){
    const i = clues.findIndex(c => makeKey(c) === keepKey);
    if (i >= 0) { currentIndex = i; currentKey = keepKey; return; }
  }

  currentIndex = 0;
  currentKey = clues[0] ? makeKey(clues[0]) : "";
}

/* ---------- loader ---------- */
function loadSheet(forceFresh=false) {
  const proxy = "https://corsproxy.io/?";
  const cacheBust = forceFresh ? `&_=${Date.now()}` : "";

  card.style.display = 'block';
  card.textContent = 'Loading‚Ä¶';

  Papa.parse(proxy + SHEET_URL + cacheBust, {
    download: true,
    header: true,
    complete: results => {
      const rows = Array.isArray(results.data) ? results.data : [];

      let clueCol='Clue', answerCol='Answer', writerCol='Writer', emailCol='', idCol='';
      let noteCol='', assessCol='', reactCol='';
      if (rows.length) {
        const keys = Object.keys(rows[0] || {});
        const keyMap = {};
        keys.forEach(k => keyMap[k.toLowerCase().replace(/\s+/g,'')] = k);
        const pick = (cands) => cands.find(c => keyMap[c.toLowerCase().replace(/\s+/g,'')]) || '';

        clueCol   = keyMap[pick(['clue','clues','cluetext'])]            || clueCol;
        answerCol = keyMap[pick(['answer','answers','solution'])]        || answerCol;
        writerCol = keyMap[pick(['writer','setter','author'])]           || writerCol;
        emailCol  = keyMap[pick(['email','writeremail','writer_email','writer e-mail','emailaddress','e-mail','contact','contactemail'])] || '';
        idCol     = keyMap[pick(['id','uid','uniqueid','unique_id'])]   || '';

        noteCol   = keyMap[pick(['note','notes'])] || '';
        assessCol = keyMap[pick(['assessment','assess'])] || '';
        reactCol  = keyMap[pick(['react','reaction','emoji'])] || '';
      }

      let fresh = rows
        .map(r => normalizeRow(r, {
          clue: clueCol, answer: answerCol, writer: writerCol,
          email: emailCol, id: idCol,
          note: noteCol, assess: assessCol, react: reactCol
        }))
        .filter(r => r.Clue && r.Answer && r.Writer);

      if (!fresh.length) {
        card.textContent = 'No rows found.';
        allClues = []; clues = []; currentIndex = 0; currentKey = "";
        queueStartSize = 0;
        lastRemainingShown = null;
        updateCounts(); updateProgress();
        return;
      }

      let saved = null;
      try {
        const raw = localStorage.getItem(PROGRESS_KEY);
        if (raw) saved = JSON.parse(raw);
      } catch {}

      const savedMap = new Map();
      if (saved && Array.isArray(saved.clues)) {
        for (const s of saved.clues) {
          const k = makeKey(s || {});
          if (k) savedMap.set(k, {
            Assessment: s.Assessment || '',
            Note: s.Note || '',
            React: s.React || ''
          });
        }
      }

      fresh = fresh.map(r => {
        const sv = savedMap.get(makeKey(r));
        if (sv && (sv.Assessment || sv.Note || sv.React)) {
          r.Assessment = sv.Assessment || '';
          r.Note = sv.Note || '';
          r.React = sv.React || '';
        }
        return r;
      });

      allClues = fresh;

      if (saved && typeof saved.currentKey === 'string') currentKey = saved.currentKey;
      else currentKey = "";

      rebuildQueue(currentKey);

      queueStartSize = clues.length;
      lastRemainingShown = null;

      updateCounts();
      updateProgress();
      showNext();
    },
    error: err => alert("Error loading sheet: " + err.message)
  });
}

/* UI updates */
function updateCounts() {
  counts.No=counts.Workshop=counts.Perfect=0;
  allClues.forEach(c=>{ if(c.Assessment){ counts[c.Assessment] = (counts[c.Assessment]||0)+1; }});
  assessmentCounts.textContent = `No: ${counts.No} | Workshop: ${counts.Workshop} | Perfect: ${counts.Perfect}`;
}
function bumpProgressFade(){
  progressCount.classList.remove('count-fade');
  void progressCount.offsetWidth;
  progressCount.classList.add('count-fade');
}
function updateProgress() {
  const remaining = clues.length;
  if (!queueStartSize) queueStartSize = remaining;

  const done = Math.max(0, queueStartSize - remaining);
  const percent = queueStartSize ? (done / queueStartSize) * 100 : 0;

  progressBar.style.width = percent + "%";
  progressCount.textContent = remaining === 1 ? "1 left" : `${remaining} left`;

  if (lastRemainingShown === null || lastRemainingShown !== remaining){
    bumpProgressFade();
    lastRemainingShown = remaining;
  }
}

/* Rendering */
function _renderCard(){
  if(currentIndex >= clues.length || clues.length === 0){
    card.innerHTML = (viewMode === "stars")
      ? "<strong>No starred clues left!</strong><br><span style='font-size:1.2rem;color:#555'>Switch to All to keep going.</span>"
      : "<strong>All done!</strong>";
    card.style.display="block";
    document.getElementById("buttons").style.display="none";
    progressBar.style.width="100%";
    progressCount.textContent = "0 left";
    bumpProgressFade();
    return;
  }

  const clue = clues[currentIndex];
  currentKey = makeKey(clue);

  const starred = isStarredWriter(clue.Writer);
  const star = starred ? `<span id="writerStar">‚≠ê</span>` : "";

  card.innerHTML = `
    <p>${clue.Clue}</p>
    <p><strong>Answer:</strong>
      <span id="answer" class="hidden" onclick="toggleAnswer(this)" data-answer="${clue.Answer}">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
    </p>
    <p id="writer" title="Long-press to star/unstar setter">${clue.Writer} ${star}</p>
  `;
  card.style.display="block";
  card.className=''; void card.offsetWidth; card.classList.add('enter');

  if (paletteOpen) closeReactPalette();

  attachWriterLongPress();
  saveProgress();
  updateProgress();
}
let showNext = _renderCard;

/* Answer reveal */
function toggleAnswer(el){
  buzz(10);
  if(el.classList.contains('revealed')){
    el.classList.remove('revealed'); el.textContent="‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà";
  } else {
    el.classList.add('revealed'); el.textContent=el.getAttribute('data-answer');
  }
}

/* Flash + swipe */
function flashMessage(direction){
  const emojiMap={ right:"üí°", left:"‚ùå", down:"‚≠ê" };
  flash.textContent=emojiMap[direction]||"";
  flash.classList.add("show");
  setTimeout(()=>flash.classList.remove("show"),600);
}
function animateSwipe(direction,callback){
  buzz(20);
  card.classList.add(`swipe-${direction}`);
  flashMessage(direction);
  setTimeout(()=>{ card.className=''; callback(); },400);
}

/* Record / undo */
function recordAssessment(value){
  if(currentIndex >= clues.length) return;

  const clue = clues[currentIndex];
  if (!clue) return;

  const key = makeKey(clue);

  // FIX: write directly onto the current clue object (no fragile lookup)
  clue.Assessment = value;

  if (!clue.React && DEFAULT_REACT[value]) {
    clue.React = DEFAULT_REACT[value];
  }

  historyKeys.push(key);
  saveProgress();

  rebuildQueue("");
  pendingQueueRebuild = false;

  updateCounts();
  showNext();
}

function undoAssessment(){
  if(historyKeys.length===0) return;
  buzz(20);

  const key = historyKeys.pop();

  // Clear assessment on the master record (safe; even if key collision, this is the best we can do)
  const master = allClues.find(c => makeKey(c) === key);
  if (!master) return;

  master.Assessment = "";

  saveProgress();

  rebuildQueue(key);
  updateCounts();
  showNext();
}

/* Export (UTF-8 BOM for emoji) ‚Äî includes Email + Id when present */
function exportCSV(){
  buzz(15);
  const filtered = allClues.filter(c=> c.Assessment || c.Note);
  const rows = filtered.map(c=>({
    Clue: c.Clue || "",
    Answer: c.Answer || "",
    Writer: c.Writer || "",
    Email: c.Email || "",
    Id: c.Id || "",
    Assessment: c.Assessment || "",
    Note: c.Note || "",
    React: c.React || ""
  }));
  const csv = Papa.unparse(rows);
  const bom = '\ufeff';
  const blob = new Blob([bom + csv],{type:"text/csv;charset=utf-8;"});
  const link=document.createElement("a");
  link.href=URL.createObjectURL(blob);
  link.download="reviewed_clues.csv";
  link.click();
}

/* Persistence */
function saveProgress(){
  try{
    localStorage.setItem(PROGRESS_KEY, JSON.stringify({
      currentKey,
      clues: allClues
    }));
  }catch(e){
    console.warn('saveProgress failed', e);
  }
}

function resetProgress(){
  if(confirm("Are you sure you want to reset clue progress? (Assessments, notes, reactions)")){
    buzz(25);
    localStorage.removeItem(PROGRESS_KEY);

    historyKeys.length = 0;
    currentIndex = 0;
    currentKey = "";
    pendingQueueRebuild = false;

    queueStartSize = 0;
    lastRemainingShown = null;

    loadSheet(true);
  }
}

/* Notes */
function openNote(){
  buzz(10);
  if (currentIndex>=clues.length) return;

  noteOpen = true;
  const clue = clues[currentIndex];
  noteTargetKey = makeKey(clue);
  lockUI();

  const noteOverlay = document.getElementById("noteOverlay");
  const noteText = document.getElementById("noteText");

  // Prefer direct object (current clue) ‚Äî safe reference
  noteText.value = clue.Note || "";

  const y = window.scrollY || window.pageYOffset || 0;
  document.body.style.setProperty('--scroll-lock', `-${y}px`);
  document.body.classList.add('modal-open');

  noteOverlay.style.display = "block";
  noteText.focus();

  noteText.addEventListener('blur', noteBlurSave, { once: true });
  noteOverlay.addEventListener('keydown', escToSaveNote);
}
function noteBlurSave(){
  if (noteOpen && noteTargetKey){
    const noteText = document.getElementById("noteText");
    const master = allClues.find(c => makeKey(c) === noteTargetKey);
    if (master){
      master.Note = noteText.value;
      saveProgress();
    }
  }
}
function escToSaveNote(e){
  if (e.key === 'Escape') {
    e.preventDefault();
    saveNote();
  }
}
function saveNote(){
  buzz(15);
  const noteText = document.getElementById("noteText");
  const master = allClues.find(c => makeKey(c) === noteTargetKey);
  if (master){
    master.Note = noteText.value;
    saveProgress();
  }

  document.getElementById("noteOverlay").style.display = "none";

  const lock = getComputedStyle(document.body).getPropertyValue('--scroll-lock');
  const y = Math.abs(parseInt(lock, 10)) || 0;
  document.body.classList.remove('modal-open');
  document.body.style.removeProperty('--scroll-lock');
  window.scrollTo(0, y);

  const noteOverlay = document.getElementById("noteOverlay");
  noteOverlay.removeEventListener('keydown', escToSaveNote);
  noteOpen = false;
  noteTargetKey = null;
  unlockUI();
}

/* View toggle */
function syncViewActiveClasses(){
  document.querySelectorAll(".tab").forEach(tab=>{
    if(tab.dataset.view === viewMode) tab.classList.add("active");
    else tab.classList.remove("active");
  });
}
function setViewMode(nextMode){
  if (nextMode !== "all" && nextMode !== "stars") return;
  viewMode = nextMode;
  localStorage.setItem(VIEW_KEY, viewMode);
  syncViewActiveClasses();

  pendingQueueRebuild = false;

  rebuildQueue(currentKey);

  queueStartSize = clues.length;
  lastRemainingShown = null;

  document.getElementById("buttons").style.display = "flex";
  updateProgress();
  showNext();
}
document.querySelectorAll(".tab").forEach(tab=>{
  tab.addEventListener("click",()=>{
    setViewMode(tab.dataset.view);
  });
});
syncViewActiveClasses();

/* Swipe gestures */
const mc=new Hammer(document.body);
mc.get("swipe").set({direction:Hammer.DIRECTION_ALL});
mc.on("swipeleft",  guardUI(()=>animateSwipe("left",  ()=>recordAssessment("No"))));
mc.on("swiperight", guardUI(()=>animateSwipe("right", ()=>recordAssessment("Workshop"))));
mc.on("swipedown",  guardUI(()=>animateSwipe("down",  ()=>recordAssessment("Perfect"))));

/* Keyboard accessibility */
document.querySelectorAll('.emoji-btn').forEach(el=>{
  el.addEventListener('keydown',e=>{
    if(e.key==='Enter'||e.key===' '){ e.preventDefault(); el.click(); }
  });
});

/* React palette */
function openReactPalette(anchorEl){
  const clue = clues[currentIndex]; if(!clue) return;

  lockUI();
  const selected = clue.React || '';
  reactPalette.innerHTML = REACT_CHOICES.map(e =>
    `<span class="rp ${e===selected?'active':''}" data-emoji="${e}" title="React">${e}</span>`
  ).join('');

  const r = anchorEl.getBoundingClientRect();
  reactPalette.style.left = r.left + 'px';
  reactPalette.style.top  = (r.top - 56) + 'px';
  reactPalette.style.display = 'flex';
  reactPalette.setAttribute('aria-hidden','false');
  paletteOpen = true;

  reactPalette.querySelectorAll('.rp').forEach(el=>{
    el.addEventListener('click', ()=>{
      const e = el.dataset.emoji;
      setReact(e);
    });
  });

  const outside = (ev)=>{
    if (!reactPalette.contains(ev.target) && ev.target !== anchorEl){
      closeReactPalette();
      document.removeEventListener('mousedown', outside);
      document.removeEventListener('touchstart', outside);
    }
  };
  document.addEventListener('mousedown', outside);
  document.addEventListener('touchstart', outside);
}
function closeReactPalette(){
  reactPalette.style.display = 'none';
  reactPalette.setAttribute('aria-hidden','true');
  paletteOpen = false;
  unlockUI();
}
function setReact(emoji){
  buzz(8);
  const clue = clues[currentIndex]; if(!clue) return;

  // FIX: write directly (no lookup)
  clue.React = emoji;
  saveProgress();
  closeReactPalette();

  animateSwipe('left', () => recordAssessment('No'));
}

/* Long-press on ‚ùå opens react palette */
const noBtn = Array.from(document.querySelectorAll('#buttons .emoji-btn'))
  .find(el => el.getAttribute('aria-label') === 'No');

if (noBtn) {
  const hm = new Hammer(noBtn);
  hm.add(new Hammer.Press({ time: 450 }));

  let pressed = false;
  hm.on('press', () => { pressed = true; buzz(12); openReactPalette(noBtn); });

  noBtn.addEventListener('click', (e) => {
    if (pressed) {
      e.preventDefault();
      e.stopPropagation();
      setTimeout(()=>{ pressed=false; }, 0);
    }
  });

  const _showNext = showNext;
  showNext = function(){
    if (paletteOpen) closeReactPalette();
    _showNext();
  };
}

/* Writer long-press to star/unstar */
let writerPressHammer = null;
function attachWriterLongPress(){
  const wEl = document.getElementById('writer');
  if (!wEl) return;

  try{ writerPressHammer && writerPressHammer.destroy(); }catch{}
  writerPressHammer = new Hammer(wEl);
  writerPressHammer.add(new Hammer.Press({ time: 450 }));

  let pressed = false;

  writerPressHammer.on('press', ()=>{
    pressed = true;
    buzz(12);

    const clue = clues[currentIndex];
    if (!clue) { setTimeout(()=>{ pressed=false; }, 0); return; }

    const newState = toggleStarWriter(clue.Writer);

    if (viewMode === "stars") {
      rebuildQueue(currentKey);
    } else {
      pendingQueueRebuild = true;
    }

    flash.textContent = newState ? "‚≠ê" : "‚òÜ";
    flash.classList.add("show");
    setTimeout(()=>flash.classList.remove("show"),450);

    showNext();
    setTimeout(()=>{ pressed=false; }, 0);
  });

  wEl.addEventListener('click', (e)=>{
    if (pressed){
      e.preventDefault();
      e.stopPropagation();
    }
  });
}

/* Debug/audit helper */
function auditNotes(){
  try{
    const savedRaw = localStorage.getItem(PROGRESS_KEY);
    let saved = null; try{ saved = JSON.parse(savedRaw); }catch{}
    const mem = new Map((saved?.clues||[]).map(c=>[makeKey(c), c.Note||'']));
    const now = new Map(allClues.map(c=>[makeKey(c), c.Note||'']));
    let missing=0;
    for (const [k, v] of now){
      const sv = mem.get(k)||'';
      if ((v||'') && sv===''){ missing++; console.warn('Note present in RAM but not saved', k, v); }
    }
    if (missing>0){
      console.warn('auditNotes: some notes not persisted yet', {missing});
    }
  }catch(e){}
}
window.addEventListener('beforeunload', auditNotes);

/* Init */
loadSetterStars();
seedInitialStars();
syncViewActiveClasses();
window.onload = () => loadSheet(false);
</script>
</body>
</html>
