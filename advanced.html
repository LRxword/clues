<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>cluesmash</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Sansita+Black:ital,wght@1,900&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
<script src="https://hammerjs.github.io/dist/hammer.min.js"></script>

<style>
/* Base */
body {
  margin: 0;
  font-family: 'Montserrat', sans-serif;
  background: #cce7ff;
  min-height: 100vh;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem 1rem 7rem;
  color: white;
  user-select: none;
}
body { min-height: 100dvh; }
@supports not (height: 100dvh) { body { min-height: 100vh; } }

/* Scroll lock when Notes is open */
body.modal-open {
  position: fixed;
  width: 100%;
  overflow: hidden;
  top: var(--scroll-lock, 0);
}

/* Title */
#title-wrapper { display: flex; justify-content: center; margin-bottom: 0.5rem; }
#title-wrapper img { height: 40px; width: auto; }

/* View toggle row */
#tabs { display: flex; gap: 1rem; margin-bottom: 1rem; }

/* Toggle buttons */
.tab {
  padding: 0.6rem 1.2rem; font-size: 1rem; font-weight: 700;
  border-radius: 16px; cursor: pointer; background: #fff; color: #000;
  border: 2px solid #000; box-shadow: 4px 4px 0 #000;
  transition: transform 0.1s ease-in-out, background 0.2s ease;
}
.tab:hover { transform: translateY(-1px); }
.tab:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 #000; }
.tab.active { background: #fff2b3; color: #000; }

/* Counts & progress */
#assessmentCounts { font-size: 1.2rem; margin-bottom: 0.5rem; color: #222; }
#progress {
  width: 90vw; max-width: 500px; height: 6px;
  background: rgba(255,255,255,0.3); border-radius: 3px;
  margin-bottom: 0.3rem; overflow: hidden;
}
#progressBar { height: 100%; width: 0%; background: #ffe6e6; transition: width 0.3s ease; }
#progressCount { font-size: 1.4rem; margin-bottom: 1.5rem; text-align: center; color: #222; }

/* Subtle fade on count change */
@keyframes countFade {
  0%   { opacity: 1; transform: translateY(0); }
  35%  { opacity: 0.35; transform: translateY(1px); }
  100% { opacity: 1; transform: translateY(0); }
}
#progressCount.count-fade { animation: countFade 240ms ease-out; }

/* Clue pane */
#card {
  background: white; color: #222; border: 3px solid #000; border-radius: 20px;
  padding: 2rem 1.5rem; font-size: 2.2rem; line-height: 1.4;
  box-shadow: 6px 6px 0 #000; text-align: center; width: 80vw; max-width: 380px;
  margin-bottom: 2rem; transition: transform 0.4s ease, opacity 0.4s ease;
}

/* Swipe animations */
#card.enter { transform: translateX(0) scale(1); opacity: 1; }
#card.swipe-left { transform: translateX(-150%) rotate(-20deg); opacity: 0; }
#card.swipe-right { transform: translateX(150%) rotate(20deg); opacity: 0; }
#card.swipe-down { transform: translateY(150%) rotate(15deg); opacity: 0; }

/* Answer block */
#answer {
  cursor: pointer; padding: 0 0.4em; border-radius: 6px; font-size: 2.2rem; font-weight: 700;
  display: inline-block; background: black; color: black; letter-spacing: 0.2em;
  font-family: 'Montserrat', sans-serif; transition: background-color 0.3s ease, color 0.3s ease;
}
#answer.revealed { background: none; color: #222; letter-spacing: normal; }

#writer {
  font-size: 1.3rem; color: #555; margin-top: 1rem;
  display: inline-flex; gap: .35rem; align-items: center; justify-content: center;
}

/* Plain star */
#writerStar { font-size: 1.25rem; line-height: 1; }

/* Enumeration (NOT bold) */
#enum {
  font-size: 1.2rem;
  font-weight: 400;
  color: #777;
  margin-left: .35rem;
}

/* Emoji controls */
#buttons {
  display: flex; justify-content: center; gap: 2.2rem; width: auto; margin-bottom: 2rem; font-size: 2.5rem;
}
.emoji-btn { cursor: pointer; transition: transform 0.15s ease; text-shadow: 2px 2px 0 #000, 4px 4px 0 #000; }
.emoji-btn:hover, .emoji-btn:active { transform: scale(1.3); text-shadow: 3px 3px 0 #000, 6px 6px 0 #000; }

/* Bottom fixed buttons container */
#bottomButtons {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  display: flex;
  z-index: 1200;
}
#bottomButtons button {
  flex: 1;
  padding: 1rem;
  font-size: 1.1rem;
  border-radius: 0;
  color: white;
  text-align: center;
  border: none;
  cursor: pointer;
}
#exportBtn { background-color: #222; }
#resetBtn  { background-color: #e53935; }

/* Flash emoji */
#flashMessage {
  position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0.8);
  font-size: 5rem; opacity: 0; transition: opacity 0.4s ease, transform 0.4s ease;
  pointer-events: none; z-index: 999; text-shadow: 2px 2px 20px rgba(0,0,0,0.6);
}
#flashMessage.show { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }

/* Note overlay */
#noteOverlay {
  display: none; position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
  width: 75%; max-width: 300px; background: white; color: #222; border-radius: 20px;
  padding: 1.5rem; box-shadow: 0 10px 25px rgba(0,0,0,0.3); z-index: 1000;
}
#noteText {
  width: 85%; height: 120px; font-size: 2.2rem; padding: 1rem; border-radius: 12px;
  border: 2px solid #222; resize: none; background: white; color: #222; line-height: 1.4;
}
#noteOverlay button {
  margin-top: 1rem; padding: 0.6rem 1rem; font-weight: 700; border-radius: 16px;
  border: none; background: #222; color: white; cursor: pointer;
}

/* React palette (long-press on ‚ùå) */
#reactPalette{
  position: fixed; display: none; background:#fff; color:#000; border:2px solid #000;
  border-radius:14px; padding:.35rem .5rem; box-shadow:6px 6px 0 #000; z-index:1100; font-size:1.6rem; gap:.5rem;
}
#reactPalette .rp{ cursor:pointer; padding:.1rem .3rem; border-radius:10px; border:2px solid transparent; }
#reactPalette .rp.active{ background:#fff2b3; border-color:#000; }
</style>
</head>

<body>
<div id="title-wrapper">
  <img src="https://i.imgur.com/3cTvC1h.png" alt="cluesmash logo">
</div>

<div id="tabs">
  <div class="tab" data-view="all">All</div>
  <div class="tab" data-view="stars">Star Setters</div>
</div>

<div id="assessmentCounts">No: 0 | Workshop: 0 | Perfect: 0</div>
<div id="progress"><div id="progressBar"></div></div>
<div id="progressCount"></div>
<div id="flashMessage"></div>

<div id="card" style="display:none;"></div>

<div id="buttons">
  <span class="emoji-btn" onclick="guardUI(()=>animateSwipe('left', () => recordAssessment('No')))()" aria-label="No" role="button" tabindex="0">‚ùå</span>
  <span class="emoji-btn" onclick="guardUI(()=>animateSwipe('right', () => recordAssessment('Workshop')))()" aria-label="Workshop" role="button" tabindex="0">üí°</span>
  <span class="emoji-btn" onclick="guardUI(()=>animateSwipe('down', () => recordAssessment('Perfect')))()" aria-label="Perfect" role="button" tabindex="0">‚≠ê</span>
  <span class="emoji-btn" onclick="openNote()" aria-label="Note" role="button" tabindex="0">‚úèÔ∏è</span>
  <span class="emoji-btn" onclick="undoAssessment()" aria-label="Undo" role="button" tabindex="0">‚Ü©Ô∏è</span>
</div>

<div id="reactPalette" role="dialog" aria-hidden="true"></div>

<div id="bottomButtons">
  <button id="exportBtn" onclick="exportCSV()">Download Reviewed CSV</button>
  <button id="resetBtn" onclick="resetProgress()">Reset Progress</button>
</div>

<div id="noteOverlay">
  <textarea id="noteText" placeholder="Write here..."></textarea>
  <button onclick="saveNote()">OK</button>
</div>

<script>
/* Haptics */
function buzz(ms=20){ if(navigator.vibrate) navigator.vibrate(ms); }

/* ---------- CSV source ---------- */
const SHEET_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vSsSUD7PgliCuhNkFFA3nyjes14LHlg1Gp2wuLlG5DU6FIp4CwP0lbrmGLuGe_DlhlbdM6fh_xwb2sZ/pub?output=csv";

/* ---------- Persistence keys (VERSIONED) ---------- */
const PROGRESS_KEY = "clueMatchProgress_v2_idsOnly"; // ‚úÖ only {id -> assessment/note/react}
const VIEW_KEY     = "clueMatchViewMode";
const STARS_KEY    = "clueMatchSetterStars";

/* ---------- One-time hardening: purge legacy progress keys ---------- */
function purgeLegacyProgress(){
  const kill = [
    "clueMatchProgress_main",
    "clueMatchProgress",
    "clueMatchProgress_compact_v1",
    "cluestormProgress_random",
    "clueMatchLastTab" // you can keep this, but harmless either way
  ];
  for (const k of kill){
    if (k !== "clueMatchLastTab") {
      try { localStorage.removeItem(k); } catch {}
    }
  }
}
purgeLegacyProgress();

/* ---------- Data & state ---------- */
let allClues = [];  // full dataset (current CSV only)
let clues = [];     // queue (unassessed + not Filtered)
let currentIndex = 0;
let currentId = "";
let viewMode = localStorage.getItem(VIEW_KEY) || "all";

let queueStartSize = 0;
let lastRemainingShown = null;

const historyIds = []; // undo stack stores IDs only (stable)
const counts = { No:0, Workshop:0, Perfect:0 };

/* UI */
const card = document.getElementById("card");
const flash = document.getElementById("flashMessage");
const progressBar = document.getElementById("progressBar");
const progressCount = document.getElementById("progressCount");
const assessmentCounts = document.getElementById("assessmentCounts");

/* UI locks */
let uiLocked = false;
let noteOpen = false;
let noteTargetId = null;

/* React config */
const REACT_CHOICES = ['üëè','üòÇ','ü§Ø','ü§≠','üòú'];
const DEFAULT_REACT = { No:'‚ù§Ô∏è', Workshop:'üí°', Perfect:'‚≠ê' };

const reactPalette = document.getElementById('reactPalette');
let paletteOpen = false;

/* ---------- helpers ---------- */
function lockUI(){
  uiLocked = true;
  document.getElementById('buttons').style.pointerEvents = 'none';
  card.style.pointerEvents = 'none';
}
function unlockUI(){
  uiLocked = false;
  document.getElementById('buttons').style.pointerEvents = '';
  card.style.pointerEvents = '';
}
const guardUI = (fn)=> (...args)=>{ if(!uiLocked && !noteOpen) fn(...args); };

function getWriterKey(name){
  return String(name||"").trim().replace(/\s+/g,' ').toLowerCase();
}

function safeStr(x){ return String(x ?? "").trim(); }

/* ---------- ENUMERATION from answer ---------- */
function countLetters(s){ return (String(s||"").match(/[A-Za-z]/g) || []).length; }

function enumerationFromAnswer(answer){
  // Spaces separate words -> commas. Hyphens inside a word -> hyphenated segments.
  // Example: "OLD COLLEGE TRY" -> (3,7,3)
  // Example: "SIX-FOOT-THREE" -> (3-4-5)
  const raw = String(answer||"").trim();
  if (!raw) return "";

  const words = raw.split(/\s+/).filter(Boolean);
  if (!words.length) return "";

  const wordEnums = words.map(w=>{
    const parts = w.split(/[-‚Äì‚Äî]/).filter(Boolean);
    const partCounts = parts.map(p=>countLetters(p)).filter(n=>n>0);
    if (!partCounts.length) return "";
    return partCounts.join("-");
  }).filter(Boolean);

  if (!wordEnums.length) return "";
  return `(${wordEnums.join(",")})`;
}

/* ---------- AUTO FILTER RULESET ----------
   Required rules:
   - letters-only count (ignoring spaces/punct) must be 3..10 inclusive
   - (optional but included) clue contains answer contiguously (normalised) -> Filtered
   Filtered clues never enter queue, but DO appear in export with Assessment="Filtered"
------------------------------------------ */
function answerLetterCount(ans){
  return String(ans || "").match(/[A-Za-z]/g)?.length || 0;
}
function normForContainment(s){
  return String(s || "")
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim();
}
function normAnswerForContainment(ans){
  return normForContainment(ans).replace(/\s+/g, '');
}
function applyHardFilters(clueList){
  for (const c of clueList){
    if (c.Assessment) continue; // never override human assessment or prior filter

    const ans = String(c.Answer || "").trim();
    const clue = String(c.Clue || "").trim();

    const n = answerLetterCount(ans);
    if (n > 0 && n < 3) { c.Assessment = "Filtered"; continue; }
    if (n > 10)         { c.Assessment = "Filtered"; continue; }

    // Rule: clue contains answer contiguously (normalised)
    const clueN = normForContainment(clue).replace(/\s+/g,'');
    const ansN  = normAnswerForContainment(ans);
    if (ansN && clueN.includes(ansN)) { c.Assessment = "Filtered"; continue; }
  }
}

/* ---------- progress storage (IDs only) ---------- */
let progressById = {}; // { [id]: {Assessment, Note, React} }

function loadProgress(){
  progressById = {};
  try{
    const raw = localStorage.getItem(PROGRESS_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object'){
      if (typeof parsed.currentId === 'string') currentId = parsed.currentId;
      if (parsed.byId && typeof parsed.byId === 'object') progressById = parsed.byId;
    }
  }catch{}
}

function saveProgress(){
  try{
    localStorage.setItem(PROGRESS_KEY, JSON.stringify({
      currentId,
      byId: progressById
    }));
  }catch(e){
    console.warn("saveProgress failed", e);
  }
}

function getProgressForId(id){
  const k = String(id||"").trim();
  return (k && progressById[k]) ? progressById[k] : null;
}
function setProgressForId(id, patch){
  const k = String(id||"").trim();
  if (!k) return;
  const cur = progressById[k] || {};
  progressById[k] = { ...cur, ...patch };
}

/* ---------- setter stars ---------- */
let setterStars = {};
function loadSetterStars(){
  try{
    const raw = localStorage.getItem(STARS_KEY);
    setterStars = raw ? JSON.parse(raw) : {};
    if (!setterStars || typeof setterStars !== 'object') setterStars = {};
  }catch{ setterStars = {}; }
}
function saveSetterStars(){
  try{ localStorage.setItem(STARS_KEY, JSON.stringify(setterStars)); }catch{}
}
function isStarredWriter(writerName){
  const k = getWriterKey(writerName);
  return !!setterStars[k];
}
function toggleStarWriter(writerName){
  const k = getWriterKey(writerName);
  if (!k) return false;
  setterStars[k] = !setterStars[k];
  saveSetterStars();
  return setterStars[k];
}

/* ---------- initial seed list ---------- */
const INITIAL_STAR_SETTERS = [
  "Adam Boyd","Adrian Paris","Adri√°n Par√≠s","Alex Ritter","Amanda C","Andrew Phelps","Annie R",
  "Arbel Feldman","Ayylexis","B N Z","Bill Lash","Billy Frank","CactusKex","Campbell H","Campsite",
  "Cole Baron","Dan Heath","David Hassine","Dean Harding","Doug Thompson","Dr W","Dr_H","Eamonn S",
  "Emilia D","Emily C","Ethan R","Eulerian","Felix H :)","Gabriel K.","Gregory Lewis","hattie",
  "hevorius","HFGO","Holypeanut","Jack Porter","jaimen","Jake Burrow","James & Ollie","Jamie T",
  "Jasel","Jay","JimbieP","Jo J","Jo O","Jody O","Johnny Quarrie","jojo!","jvsn89","Kelly Hicks",
  "Lee Hoe","Lucy","Luminoid","Martin","Mattasdqwe","mattLOLd","maya00","mayasibul00",
  "NatalyBenderskyShalem","Nate Mizelle","NateMiz","Nixfriarr","null","√ìin Stoch","Oren",
  "Pete Bowdon","Pete Craw","Peter Green","Phil McLean","Rob D","Rusty","Ryan Gittins","saintmark_w",
  "Sam Mount (Kaldar)","Schr√∂die‚Äôs Cat","Seivad","sngpretzel","Stevie Reed","Supware","Tanner Burton",
  "That Observer","Tyler Hopp","Tyr","vaughn","ventimony","Bluejay","hurblub"
];
function seedInitialStars(){
  if (!setterStars || typeof setterStars !== 'object') setterStars = {};
  let changed = false;
  for (const name of INITIAL_STAR_SETTERS){
    const k = getWriterKey(name);
    if (!k) continue;
    if (!(k in setterStars)){
      setterStars[k] = true;
      changed = true;
    }
  }
  if (changed) saveSetterStars();
}

/* ---------- parse & normalise row (NEW SCHEMA) ---------- */
function normalizeRow(r, cols){
  const g = (obj, key) => (obj && key && obj[key]) || '';
  const id = safeStr(g(r, cols.id));
  return {
    Id: id,
    CreatedAt: safeStr(g(r, cols.created_at)),
    Clue: safeStr(g(r, cols.clue)),
    Answer: safeStr(g(r, cols.answer)),
    Hints: safeStr(g(r, cols.hints)),
    Writer: safeStr(g(r, cols.writer)),
    Email: safeStr(g(r, cols.email)),
    Social: safeStr(g(r, cols.social)),
    UserId: safeStr(g(r, cols.user_id)),
    // persisted fields:
    Assessment: "",
    Note: "",
    React: ""
  };
}

/* ---------- queue rebuild ---------- */
function rebuildQueue(keepId=""){
  const unassessed = allClues.filter(c => !c.Assessment); // includes NOT Filtered only (Filtered has Assessment)
  let next = unassessed;

  if (viewMode === "stars"){
    next = next.filter(c => isStarredWriter(c.Writer));
  }

  if (viewMode === "all"){
    next = next
      .map((c, idx) => ({c, idx, starred: isStarredWriter(c.Writer)}))
      .sort((a,b)=>{
        if (a.starred !== b.starred) return a.starred ? -1 : 1;
        return a.idx - b.idx;
      })
      .map(x=>x.c);
  }

  clues = next;

  if (keepId){
    const i = clues.findIndex(c => c.Id === keepId);
    if (i >= 0) { currentIndex = i; currentId = keepId; return; }
  }

  currentIndex = 0;
  currentId = clues[0] ? clues[0].Id : "";
}

/* ---------- loader (ALWAYS fresh when resetting) ---------- */
function loadSheet(forceFresh=false) {
  const proxy = "https://corsproxy.io/?";
  const cacheBust = `&_=${Date.now()}`; // always fresh; prevents ‚Äúwrong old clues‚Äù via caching

  card.style.display = 'block';
  card.textContent = 'Loading‚Ä¶';

  Papa.parse(proxy + SHEET_URL + cacheBust, {
    download: true,
    header: true,
    skipEmptyLines: true,
    complete: results => {
      const rows = Array.isArray(results.data) ? results.data : [];

      if (!rows.length) {
        card.textContent = 'No rows found.';
        allClues = []; clues = []; currentIndex = 0; currentId = "";
        queueStartSize = 0;
        lastRemainingShown = null;
        updateCounts(); updateProgress();
        return;
      }

      // Detect columns (case/space tolerant, NEW schema)
      const keys = Object.keys(rows[0] || {});
      const keyMap = {};
      keys.forEach(k => keyMap[k.toLowerCase().replace(/[\s_]+/g,'')] = k);
      const pick = (cands) => cands.find(c => keyMap[c.toLowerCase().replace(/[\s_]+/g,'')]) || '';

      const cols = {
        id:          keyMap[pick(['id'])] || 'id',
        created_at:  keyMap[pick(['createdat','created_at','created at'])] || '',
        clue:        keyMap[pick(['clue','cluetext','clues'])] || 'clue',
        answer:      keyMap[pick(['answer','solution'])] || 'answer',
        hints:       keyMap[pick(['hints','hint'])] || '',
        writer:      keyMap[pick(['settername','setter_name','writer','setter','author'])] || 'setter_name',
        email:       keyMap[pick(['email','setteremail','setter_email','writeremail','writer_email'])] || '',
        social:      keyMap[pick(['settersocialhandles','setter_social_handles','social','handles'])] || '',
        user_id:     keyMap[pick(['userid','user_id'])] || ''
      };

      // Parse
      let fresh = rows
        .map(r => normalizeRow(r, cols))
        .filter(r => r.Id && r.Clue && r.Answer && r.Writer);

      if (!fresh.length) {
        card.textContent = 'No valid rows found.';
        allClues = []; clues = []; currentIndex = 0; currentId = "";
        queueStartSize = 0;
        lastRemainingShown = null;
        updateCounts(); updateProgress();
        return;
      }

      // Load progress (IDs only) and merge
      loadProgress();
      fresh = fresh.map(r=>{
        const p = getProgressForId(r.Id);
        if (p){
          r.Assessment = safeStr(p.Assessment);
          r.Note = safeStr(p.Note);
          r.React = safeStr(p.React);
        }
        return r;
      });

      allClues = fresh;

      // Apply hard filters AFTER merge so Filtered persists and never re-enters queue
      applyHardFilters(allClues);

      // Ensure filtered rows are also persisted (so they never re-enter queue on refresh)
      for (const c of allClues){
        if (c.Assessment === "Filtered"){
          setProgressForId(c.Id, { Assessment: "Filtered" });
        }
      }
      saveProgress();

      // Restore anchor if still valid
      if (currentId && !allClues.find(c=>c.Id===currentId)) currentId = "";

      rebuildQueue(currentId);

      queueStartSize = clues.length;
      lastRemainingShown = null;

      updateCounts();
      updateProgress();
      showNext();
    },
    error: err => alert("Error loading CSV: " + err.message)
  });
}

/* UI updates */
function updateCounts() {
  counts.No=counts.Workshop=counts.Perfect=0;
  allClues.forEach(c=>{
    if (c.Assessment === "No") counts.No++;
    else if (c.Assessment === "Workshop") counts.Workshop++;
    else if (c.Assessment === "Perfect") counts.Perfect++;
  });
  assessmentCounts.textContent = `No: ${counts.No} | Workshop: ${counts.Workshop} | Perfect: ${counts.Perfect}`;
}
function bumpProgressFade(){
  progressCount.classList.remove('count-fade');
  void progressCount.offsetWidth;
  progressCount.classList.add('count-fade');
}
function updateProgress() {
  const remaining = clues.length;
  if (!queueStartSize) queueStartSize = remaining;

  const done = Math.max(0, queueStartSize - remaining);
  const percent = queueStartSize ? (done / queueStartSize) * 100 : 0;

  progressBar.style.width = percent + "%";
  progressCount.textContent = remaining === 1 ? "1 left" : `${remaining} left`;

  if (lastRemainingShown === null || lastRemainingShown !== remaining){
    bumpProgressFade();
    lastRemainingShown = remaining;
  }
}

/* Rendering */
function _renderCard(){
  if(currentIndex >= clues.length || clues.length === 0){
    card.innerHTML = (viewMode === "stars")
      ? "<strong>No starred clues left!</strong><br><span style='font-size:1.2rem;color:#555'>Switch to All to keep going.</span>"
      : "<strong>All done!</strong>";
    card.style.display="block";
    document.getElementById("buttons").style.display="none";
    progressBar.style.width="100%";
    progressCount.textContent = "0 left";
    bumpProgressFade();
    return;
  }

  const clue = clues[currentIndex];
  currentId = clue.Id;
  saveProgress(); // keep anchor current

  const starred = isStarredWriter(clue.Writer);
  const star = starred ? `<span id="writerStar">‚≠ê</span>` : "";
  const enumText = enumerationFromAnswer(clue.Answer);

  card.innerHTML = `
    <p>${clue.Clue}<span id="enum">${enumText ? " " + enumText : ""}</span></p>
    <p><strong>Answer:</strong>
      <span id="answer" class="hidden" onclick="toggleAnswer(this)" data-answer="${escapeHtml(clue.Answer)}">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
    </p>
    <p id="writer" title="Long-press to star/unstar setter">${escapeHtml(clue.Writer)} ${star}</p>
  `;

  card.style.display="block";
  card.className=''; void card.offsetWidth; card.classList.add('enter');

  if (paletteOpen) closeReactPalette();

  attachWriterLongPress();
  updateProgress();
}
let showNext = _renderCard;

/* Basic HTML escaping for Answer/Writer */
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

/* Answer reveal */
function toggleAnswer(el){
  buzz(10);
  if(el.classList.contains('revealed')){
    el.classList.remove('revealed'); el.textContent="‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà";
  } else {
    el.classList.add('revealed'); el.textContent=el.getAttribute('data-answer');
  }
}

/* Flash + swipe */
function flashMessage(direction){
  const emojiMap={ right:"üí°", left:"‚ùå", down:"‚≠ê" };
  flash.textContent=emojiMap[direction]||"";
  flash.classList.add("show");
  setTimeout(()=>flash.classList.remove("show"),600);
}
function animateSwipe(direction,callback){
  buzz(20);
  card.classList.add(`swipe-${direction}`);
  flashMessage(direction);
  setTimeout(()=>{ card.className=''; callback(); },400);
}

/* Record / undo */
function recordAssessment(value){
  if(currentIndex >= clues.length) return;

  const clue = clues[currentIndex];
  const id = clue.Id;

  clue.Assessment = value;
  if (!clue.React && DEFAULT_REACT[value]) clue.React = DEFAULT_REACT[value];

  setProgressForId(id, { Assessment: clue.Assessment, Note: clue.Note || "", React: clue.React || "" });

  historyIds.push(id);
  currentId = id;
  saveProgress();

  rebuildQueue(""); // remove assessed & re-sort
  updateCounts();
  showNext();
}

function undoAssessment(){
  if(historyIds.length===0) return;
  buzz(20);

  const id = historyIds.pop();
  const master = allClues.find(c => c.Id === id);
  if (!master) return;

  master.Assessment = "";
  // (leave Note/React intact if you want; or clear React too ‚Äî currently we leave it)
  setProgressForId(id, { Assessment: "" });

  currentId = id;
  saveProgress();

  rebuildQueue(id);
  updateCounts();
  showNext();
}

/* Export (includes Filtered) */
function exportCSV(){
  buzz(15);
  const out = allClues.filter(c => (c.Assessment || c.Note)); // include Filtered automatically
  const rows = out.map(c=>({
    id: c.Id || "",
    created_at: c.CreatedAt || "",
    clue: c.Clue || "",
    answer: c.Answer || "",
    hints: c.Hints || "",
    setter_name: c.Writer || "",
    email: c.Email || "",
    setter_social_handles: c.Social || "",
    user_id: c.UserId || "",
    assessment: c.Assessment || "",
    note: c.Note || "",
    react: c.React || ""
  }));
  const csv = Papa.unparse(rows);
  const bom = '\ufeff';
  const blob = new Blob([bom + csv],{type:"text/csv;charset=utf-8;"});
  const link=document.createElement("a");
  link.href=URL.createObjectURL(blob);
  link.download="reviewed_clues.csv";
  link.click();
}

/* Reset progress (stars untouched; ALWAYS reloads latest CSV) */
function resetProgress(){
  if(confirm("Are you sure you want to reset clue progress? (Assessments, notes, reactions)")){
    buzz(25);

    try{ localStorage.removeItem(PROGRESS_KEY); }catch{}
    progressById = {};
    historyIds.length = 0;
    currentIndex = 0;
    currentId = "";

    queueStartSize = 0;
    lastRemainingShown = null;

    loadSheet(true); // fresh cache-bust always
  }
}

/* Notes */
function openNote(){
  buzz(10);
  if (currentIndex>=clues.length) return;

  noteOpen = true;
  const clue = clues[currentIndex];
  noteTargetId = clue.Id;
  lockUI();

  const noteOverlay = document.getElementById("noteOverlay");
  const noteText = document.getElementById("noteText");
  noteText.value = clue.Note || "";

  const y = window.scrollY || window.pageYOffset || 0;
  document.body.style.setProperty('--scroll-lock', `-${y}px`);
  document.body.classList.add('modal-open');

  noteOverlay.style.display = "block";
  noteText.focus();

  noteText.addEventListener('blur', noteBlurSave, { once: true });
  noteOverlay.addEventListener('keydown', escToSaveNote);
}
function noteBlurSave(){
  if (noteOpen && noteTargetId){
    const noteText = document.getElementById("noteText");
    const master = allClues.find(c => c.Id === noteTargetId);
    if (master){
      master.Note = noteText.value;
      setProgressForId(noteTargetId, { Note: master.Note });
      saveProgress();
    }
  }
}
function escToSaveNote(e){
  if (e.key === 'Escape') {
    e.preventDefault();
    saveNote();
  }
}
function saveNote(){
  buzz(15);
  const noteText = document.getElementById("noteText");
  const master = allClues.find(c => c.Id === noteTargetId);
  if (master){
    master.Note = noteText.value;
    setProgressForId(noteTargetId, { Note: master.Note });
    saveProgress();
  }

  document.getElementById("noteOverlay").style.display = "none";

  const lock = getComputedStyle(document.body).getPropertyValue('--scroll-lock');
  const y = Math.abs(parseInt(lock, 10)) || 0;
  document.body.classList.remove('modal-open');
  document.body.style.removeProperty('--scroll-lock');
  window.scrollTo(0, y);

  const noteOverlay = document.getElementById("noteOverlay");
  noteOverlay.removeEventListener('keydown', escToSaveNote);
  noteOpen = false;
  noteTargetId = null;
  unlockUI();
}

/* View toggle */
function syncViewActiveClasses(){
  document.querySelectorAll(".tab").forEach(tab=>{
    if(tab.dataset.view === viewMode) tab.classList.add("active");
    else tab.classList.remove("active");
  });
}
function setViewMode(nextMode){
  if (nextMode !== "all" && nextMode !== "stars") return;
  viewMode = nextMode;
  localStorage.setItem(VIEW_KEY, viewMode);
  syncViewActiveClasses();

  rebuildQueue(currentId);

  queueStartSize = clues.length;
  lastRemainingShown = null;

  document.getElementById("buttons").style.display = "flex";
  updateProgress();
  showNext();
}
document.querySelectorAll(".tab").forEach(tab=>{
  tab.addEventListener("click",()=> setViewMode(tab.dataset.view));
});

/* Swipe gestures */
const mc=new Hammer(document.body);
mc.get("swipe").set({direction:Hammer.DIRECTION_ALL});
mc.on("swipeleft",  guardUI(()=>animateSwipe("left",  ()=>recordAssessment("No"))));
mc.on("swiperight", guardUI(()=>animateSwipe("right", ()=>recordAssessment("Workshop"))));
mc.on("swipedown",  guardUI(()=>animateSwipe("down",  ()=>recordAssessment("Perfect"))));

/* Keyboard accessibility */
document.querySelectorAll('.emoji-btn').forEach(el=>{
  el.addEventListener('keydown',e=>{
    if(e.key==='Enter'||e.key===' '){ e.preventDefault(); el.click(); }
  });
});

/* React palette */
function openReactPalette(anchorEl){
  const clue = clues[currentIndex]; if(!clue) return;

  lockUI();
  const selected = clue.React || '';
  reactPalette.innerHTML = REACT_CHOICES.map(e =>
    `<span class="rp ${e===selected?'active':''}" data-emoji="${e}" title="React">${e}</span>`
  ).join('');

  const r = anchorEl.getBoundingClientRect();
  reactPalette.style.left = r.left + 'px';
  reactPalette.style.top  = (r.top - 56) + 'px';
  reactPalette.style.display = 'flex';
  reactPalette.setAttribute('aria-hidden','false');
  paletteOpen = true;

  reactPalette.querySelectorAll('.rp').forEach(el=>{
    el.addEventListener('click', ()=>{
      const e = el.dataset.emoji;
      setReact(e);
    });
  });

  const outside = (ev)=>{
    if (!reactPalette.contains(ev.target) && ev.target !== anchorEl){
      closeReactPalette();
      document.removeEventListener('mousedown', outside);
      document.removeEventListener('touchstart', outside);
    }
  };
  document.addEventListener('mousedown', outside);
  document.addEventListener('touchstart', outside);
}
function closeReactPalette(){
  reactPalette.style.display = 'none';
  reactPalette.setAttribute('aria-hidden','true');
  paletteOpen = false;
  unlockUI();
}
function setReact(emoji){
  buzz(8);
  const clue = clues[currentIndex]; if(!clue) return;

  clue.React = emoji;
  setProgressForId(clue.Id, { React: clue.React });
  saveProgress();
  closeReactPalette();

  animateSwipe('left', () => recordAssessment('No'));
}

/* Long-press on ‚ùå opens react palette; short tap still rejects */
const noBtn = Array.from(document.querySelectorAll('#buttons .emoji-btn'))
  .find(el => el.getAttribute('aria-label') === 'No');

if (noBtn) {
  const hm = new Hammer(noBtn);
  hm.add(new Hammer.Press({ time: 450 }));

  let pressed = false;
  hm.on('press', () => { pressed = true; buzz(12); openReactPalette(noBtn); });

  noBtn.addEventListener('click', (e) => {
    if (pressed) {
      e.preventDefault();
      e.stopPropagation();
      setTimeout(()=>{ pressed=false; }, 0);
    }
  });

  const _showNext = showNext;
  showNext = function(){
    if (paletteOpen) closeReactPalette();
    _showNext();
  };
}

/* Writer long-press to star/unstar */
let writerPressHammer = null;
function attachWriterLongPress(){
  const wEl = document.getElementById('writer');
  if (!wEl) return;

  try{ writerPressHammer && writerPressHammer.destroy(); }catch{}
  writerPressHammer = new Hammer(wEl);
  writerPressHammer.add(new Hammer.Press({ time: 450 }));

  let pressed = false;

  writerPressHammer.on('press', ()=>{
    pressed = true;
    buzz(12);

    const clue = clues[currentIndex];
    if (!clue) { setTimeout(()=>{ pressed=false; }, 0); return; }

    const newState = toggleStarWriter(clue.Writer);

    if (viewMode === "stars") {
      rebuildQueue(currentId);
    }

    flash.textContent = newState ? "‚≠ê" : "‚òÜ";
    flash.classList.add("show");
    setTimeout(()=>flash.classList.remove("show"),450);

    showNext();
    setTimeout(()=>{ pressed=false; }, 0);
  });

  wEl.addEventListener('click', (e)=>{
    if (pressed){
      e.preventDefault();
      e.stopPropagation();
    }
  });
}

/* Init */
loadSetterStars();
seedInitialStars();
syncViewActiveClasses();
window.onload = () => {
  loadProgress();
  loadSheet(false);
};
</script>
</body>
</html>
